import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { getThreatParameter, THREAT_PARAMETERS } from "@/data/threatParameters";
import { applyThreatMods } from "@/utils/threatModifiers";

export interface AbilityScores {
  strength: number;
  dexterity: number;
  constitution: number;
  intelligence: number;
  wisdom: number;
  charisma: number;
}

export interface Defenses {
  avoidance: number;
  fortitude: number;
  willpower: number;
}

export interface AttackInfo {
  single: number;
  area: number;
}

export interface DamageInfo {
  min: number;
  max: number;
  avg: number;
}

export interface ThreatAction {
  id: string;
  name: string;
  type: "Attack" | "Non-Attack";
  actionType?: "Action" | "Bonus" | "Demanding" | "Reaction";
  description: string;
  toHit?: number;
  damage?: string;
  damageType?: string;
  defense?: string;
  range?: string;
  area?: string;
  duration?: string;
  frequency?: string;
  effects?: string;
  notes?: string;
  successText?: string;
  autoGenerated: boolean;
  source: string;
}

export interface ThreatFeature {
  id: string;
  name: string;
  description: string;
  type: "trait" | "immunity" | "Damage Resistance" | "vulnerability" | "special";
  source: string;
  autoGenerated: boolean;
}

export interface Threat {
  name: string;
  rank: string;
  role: string;
  size: string;
  type: string;
  abilityScores: AbilityScores;
  defenses: Defenses;
  stamina: number;
  wounds: number;
  attack: AttackInfo;
  damage: DamageInfo;
  initiative: number;
  pace: string;
  basePace: number;
  additionalPaces: Array<{ type: string; value: number | string }>;
  traits: string[];
  skillSets: string[];
  actions: ThreatAction[];
  features: ThreatFeature[];
  advanced: boolean;
  advancedRanks?: {
    attack: string;
    defense: string;
    durability: string;
  };
  effectiveRank: number; // for advanced averaging
  pendingDefenseValues: number[] | null;
  defenseAssigned: boolean;
  defenseAssignment?: {
    avoidance?: number;
    fortitude?: number;
    willpower?: number;
  };
}

const defaultThreat: Threat = {
  name: "",
  rank: "Zeta",
  role: "",
  size: "Medium",
  type: "",
  abilityScores: {
    strength: 10,
    dexterity: 10,
    constitution: 10,
    intelligence: 10,
    wisdom: 10,
    charisma: 10,
  },
  defenses: { avoidance: 0, fortitude: 0, willpower: 0 },
  stamina: 0,
  wounds: 0,
  attack: { single: 0, area: 0 },
  damage: { min: 0, max: 0, avg: 0 },
  initiative: 0,
  pace: "",
  basePace: 2,
  additionalPaces: [],
  traits: [],
  skillSets: [],
  actions: [],
  features: [],
  advanced: false,
  effectiveRank: 1,
  pendingDefenseValues: null,
  defenseAssigned: false,
};

interface ThreatContextType {
  threat: Threat;
  setThreat: React.Dispatch<React.SetStateAction<Threat>>;
  updateThreatField: (field: keyof Threat, value: any) => void;
  addTrait: (trait: string) => void;
  removeTrait: (index: number) => void;
  addSkillSet: (skill: string) => void;
  removeSkillSet: (index: number) => void;
  currentStep: number;
  setCurrentStep: (n: number) => void;
  applyParameters: (label: string) => void;
  applyAdvancedParameters: (defenseLabel: string, durabilityLabel: string, attackLabel: string) => void;
  commitDefenseAssignment: (mapping: { avoidance: number; fortitude: number; willpower: number }) => void;
  resetThreat: () => void;
}

const ThreatContext = createContext<ThreatContextType | undefined>(undefined);

export function ThreatProvider({ children }: { children: ReactNode }) {
  const [threat, setThreat] = useState<Threat>(() => {
    const base = { ...defaultThreat };
    const params = getThreatParameter(base.rank);
    if (params) {
      // Set pending defense values but don't auto-assign them
      base.pendingDefenseValues = [...params.defenses];
      base.defenseAssigned = false;
      base.stamina = params.stamina;
      base.wounds = params.wounds;
      base.attack = { single: params.toHit[0], area: params.toHit[1] };
      base.damage = { ...params.damage };
      base.effectiveRank = params.rank;
    }
    return base;
  });
  const [currentStep, setCurrentStep] = useState(1);

  // Apply threat modifiers automatically when relevant parameters change
  useEffect(() => {
    if (threat.defenseAssigned && threat.role && threat.size && threat.type) {
      setThreat(prev => applyThreatMods(prev));
    }
  }, [threat.role, threat.size, threat.type, threat.defenseAssigned, threat.abilityScores.dexterity, threat.basePace]);

  const updateThreatField = (field: keyof Threat, value: any) => {
    setThreat((prev) => ({ ...prev, [field]: value }));
  };

  const addTrait = (trait: string) => {
    setThreat((prev) => ({ ...prev, traits: [...prev.traits, trait] }));
  };

  const removeTrait = (index: number) => {
    setThreat((prev) => ({
      ...prev,
      traits: prev.traits.filter((_, i) => i !== index),
    }));
  };

  const addSkillSet = (skill: string) => {
    setThreat((prev) => ({ ...prev, skillSets: [...prev.skillSets, skill] }));
  };

  const removeSkillSet = (index: number) => {
    setThreat((prev) => ({
      ...prev,
      skillSets: prev.skillSets.filter((_, i) => i !== index),
    }));
  };

  const applyParameters = (label: string) => {
    const params = getThreatParameter(label);
    if (!params) return;
    setThreat((prev) => ({
      ...prev,
      rank: label,
      pendingDefenseValues: [...params.defenses],
      defenseAssigned: false,
      defenses: { avoidance: 0, fortitude: 0, willpower: 0 }, // Clear until assigned
      stamina: params.stamina,
      wounds: params.wounds,
      attack: { single: params.toHit[0], area: params.toHit[1] },
      damage: { ...params.damage },
      effectiveRank: params.rank,
      advanced: false,
      advancedRanks: undefined,
      defenseAssignment: undefined,
    }));
  };

  const applyAdvancedParameters = (
    defenseLabel: string,
    durabilityLabel: string,
    attackLabel: string,
  ) => {
    const def = getThreatParameter(defenseLabel) || THREAT_PARAMETERS[0];
    const dur = getThreatParameter(durabilityLabel) || THREAT_PARAMETERS[0];
    const atk = getThreatParameter(attackLabel) || THREAT_PARAMETERS[0];
    const avg = (def.rank + dur.rank + atk.rank) / 3;
    const closest = THREAT_PARAMETERS.reduce((prev, curr) =>
      Math.abs(curr.rank - avg) < Math.abs(prev.rank - avg) ? curr : prev
    );
    setThreat((prev) => ({
      ...prev,
      rank: closest.label,
      pendingDefenseValues: [...def.defenses], // Use defense rank for the pool
      defenseAssigned: false,
      defenses: { avoidance: 0, fortitude: 0, willpower: 0 }, // Clear until assigned
      stamina: dur.stamina,
      wounds: dur.wounds,
      attack: { single: atk.toHit[0], area: atk.toHit[1] },
      damage: { ...atk.damage },
      effectiveRank: parseFloat(avg.toFixed(2)),
      advanced: true,
      advancedRanks: {
        attack: attackLabel,
        defense: defenseLabel,
        durability: durabilityLabel,
      },
      defenseAssignment: undefined,
    }));
  };

  const commitDefenseAssignment = (mapping: { avoidance: number; fortitude: number; willpower: number }) => {
    setThreat((prev) => ({
      ...prev,
      defenses: { ...mapping },
      defenseAssignment: { ...mapping },
      defenseAssigned: true,
      pendingDefenseValues: null,
    }));
  };

  const resetThreat = () => {
    setThreat(() => {
      const base = { ...defaultThreat };
      const params = getThreatParameter(base.rank);
      if (params) {
        base.pendingDefenseValues = [...params.defenses];
        base.defenseAssigned = false;
        base.stamina = params.stamina;
        base.wounds = params.wounds;
        base.attack = { single: params.toHit[0], area: params.toHit[1] };
        base.damage = { ...params.damage };
        base.effectiveRank = params.rank;
      }
      return base;
    });
    setCurrentStep(1);
  };

  const value: ThreatContextType = {
    threat,
    setThreat,
    updateThreatField,
    addTrait,
    removeTrait,
    addSkillSet,
    removeSkillSet,
    currentStep,
    setCurrentStep,
    applyParameters,
    applyAdvancedParameters,
    commitDefenseAssignment,
    resetThreat,
  };

  return <ThreatContext.Provider value={value}>{children}</ThreatContext.Provider>;
}

export function useThreat() {
  const context = useContext(ThreatContext);
  if (!context) {
    throw new Error("useThreat must be used within a ThreatProvider");
  }
  return context;
}
